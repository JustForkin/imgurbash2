#!/usr/bin/env bash
# Copyright (c) 2016-2017 Ramon <https://github.com/ram-on/imgurbash2>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#--------------------------------------------------------------------
# AUTHORS:  Ramon <https://github.com/ram-on/imgurbash2>
#           Originally written by Bart Nagel <bart@tremby.net>
#           Config & auth logic inspired by https://github.com/jomo/imgur-screenshot/
# REQUIRED: curl
# OPTIONAL:
#	* xsel or xclip for copying URLs to your clipboard (Linux)
#	* notify-send for notifications (Linux)
#	* growlnotify or terminal-notifier for notifications (macOS)
#--------------------------------------------------------------------
#
# The URLs will be output on your terminal. If you have xsel or xclip they
# will also be copied on clipboard, which you can usually paste with a CTRL-V.

set -a

readonly SELF=${0##*/}
readonly CONF_ROOT="$HOME/.config/imgurbash2"

readonly CONF_FILE="$CONF_ROOT/config"
readonly VERSION=3
readonly TOKEN_URL="https://api.imgur.com/oauth2/token"
readonly JOB_ID="$$"
uname | grep -q "Darwin" && IS_MAC=1 || IS_MAC=0

HAS_ERRORS=0  # flag indicating if any errors were encountered

declare -A COLORS=(
	[RED]=$'\033[0;31m'
	[GREEN]=$'\033[0;32m'
	[BLUE]=$'\033[0;34m'
	[PURPLE]=$'\033[0;35m'
	[CYAN]=$'\033[0;36m'
	[WHITE]=$'\033[0;37m'
	[YELLOW]=$'\033[0;33m'
	[BOLD]=$'\033[1m'
	[OFF]=$'\033[0m'
)


# Print usage info.
#
# @returns {void}
usage() {
	echo "
    Uploads images to imgur and output their imgurl URL link. It can also delete
    previously uploaded images.

    The URL links are then copied to your clipboard, given required dependencies are found.

    ${COLORS[GREEN]}Usage:${COLORS[OFF]}
        ${COLORS[CYAN]}${SELF}${COLORS[OFF]} [option] <image1> [image2...]

    Where
        image* is a local file or a remote image (eg http://domain/myimage.png)

    ${COLORS[GREEN]}Options:${COLORS[OFF]}
        ${COLORS[GREEN]}-d, --delete${COLORS[OFF]} <delete_hash1> [delete_hash2...]
            Deletes image(s) based on supplied delete hash.
        ${COLORS[GREEN]}-D, --auto-delete${COLORS[OFF]} <delay>
            Where <delay> is argument accepted by \$sleep (eg 20, 15m, 1h).
            If provided, uploaded image(s) will be automatically deleted
            after given time has elapsed; note this assumes your computer
            won't be halted/suspended before the time has passed.
        ${COLORS[GREEN]}-l, --login${COLORS[OFF]} <true|false>
            state whether authenticated operation is required.
            if 'true', then credentials need to be set up in
            [$CREDENTIALS_FILE] beforehand.
        ${COLORS[GREEN]}-a, --album-id${COLORS[OFF]} <id>
            Id of an album if image to upload should belong in an album.
        ${COLORS[GREEN]}-t, --title${COLORS[OFF]} <title>
            Title for the image(s) to be uploaded
        ${COLORS[GREEN]}-h, --help${COLORS[OFF]}
            Displays this help.
        ${COLORS[GREEN]}-v, --version${COLORS[OFF]}
            Prints script version.
    ${COLORS[GREEN]}Examples:${COLORS[OFF]}
        Refer to https://github.com/ram-on/imgurbash2
"
}


#
# Given a string it will try to extract its values (from the given JSON response).
# E.g.  '"error":"Invalid client_id"' ==> string = "error", value = "Invalid client_id"
#
# Paramateres:
#   $1 - Response JSON.
#   $2 - 'String' (not datatype) which will be used to get the value from.
#
function get_value_from_response() {
	sed -e 's/.*\"'$2'\":"\([^"]*\).*/\1/' <<< "$1"
}


#
# Given a string it will try to extract its values that are not enclosed by
# commas (from the given JSON response).
# E.g.  '"status":200' ==> string = "status", value = "200"
#
# Paramateres:
#   $1 - Response JSON.
#   $2 - 'String' (not datatype) which will be used to get the value from.
#
function get_value_from_response_no_inverted_commas() {
	sed -e 's/.*\"'$2'\":\([^,}]*\).*/\1/' <<< "$1"
}


# Checks whether given url is a valid one.
# Note we only check for https? protocol.
#
# @param {string}  url   url which validity to test.
#
# @returns {bool}  true, if provided url was a valid url.
is_valid_url() {
	local url regex

	url="$1"

	regex='https?://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'

	[[ "$url" =~ $regex ]]
}


# Checks whether given string is empty or 'null'.
#
# @param {string}  str   string to check.
#
# @returns {bool}  true, if provided string is empty or 'null'
is_null_or_empty() {
	[[ -z "$*" || "$*" == null ]]
}


# Performs call to imgur api.
# Injects appropriate curl headers, depending on whether authorized
# or anon request is being made.
#
# @param {string}     -r resource   api resource to hit.
# @param {string...}  hdrs          additional curl options.
#
# @returns {string}  response body, as returned by curl.
api_call() {
	local hdrs resource

	if [[ "$1" == '-r' || "$1" == '--resource' ]] && [[ -n "$2" ]]; then
		resource="$2"
		shift 2
	else
		fail "no resource given when calling ${FUNCNAME}()"
	fi

	declare -a hdrs=("$@")
	[[ "$LOGIN" == true ]] && hdrs+=('-H' "Authorization: Bearer ${ACCESS_TOKEN}") \
			|| hdrs+=('-H' "Authorization: Client-ID $ANON_CLIENT_ID")

	curl --compressed \
			--connect-timeout "$API_CALL_CONNECT_TIMEOUT_SEC" \
			-m "$API_CALL_TIMEOUT_SEC" \
			--retry "$API_CALL_RETRIES" \
			--stderr - \
			-sSL \
			"${hdrs[@]}" \
			"https://api.imgur.com/3/${resource}"
}


# Uploads given image to imgur.
#
# @param {string}  file   path to local image file, or external URL.
#
# @returns {string}  response body, as returned by curl.
upload_image() {
	local file hdrs

	file="$1"
	declare -a hdrs=('-X' POST)

	[[ -n "$TITLE" ]] && hdrs+=('-F' "title=$TITLE")
	[[ -n "$ALBUM_ID" ]] && hdrs+=('-F' "album=$ALBUM_ID")

	if [[ -f "$file" ]]; then
		hdrs+=('-F' "image=@$file")
	elif is_valid_url "$file"; then
		# TODO: only works when album_id not defined?
		hdrs+=('--data-urlencode' "image=$file")
	else
		err "File [$file] does not exist, skipping"
		return 1
	fi

	api_call -r image "${hdrs[@]}"
}


# Pops a notification message
#
# @param {string}  -t ttl  OPTIONAL message ttl in millisec (linux only atm);
#                          value of 0 means no ttl;
# @param {string}  lvl     message level. ERROR | INFO
# @param {string}  msg     message to print.
#
# @returns {void}
notify() {
	local opt ttl lvl msg default_ttl

	default_ttl=5000

	while getopts "t:" opt; do
		case "$opt" in
			t) ttl="$OPTARG" ;;
			*) usage; exit 1 ;;  # do not call fail() to avoid circular dep
		esac
	done
	shift $((OPTIND-1))


	lvl="$1"
	msg="$2"

	ttl="${ttl:-$default_ttl}"

	[[ "$ENABLE_NOTIFICATIONS" != true ]] && return

	if [[ "$IS_MAC" -eq 1 ]]; then
		if which growlnotify &>/dev/null; then
			growlnotify --title "$SELF" --message "$msg"
		else
			terminal-notifier -title "$SELF" -message "$msg"
		fi
	else
		if [[ "$lvl" == ERROR ]]; then
			notify-send -a ImgurScreenshot -u critical -c "im.error" -t "$ttl" "$SELF" "$msg"
		elif [[ "$NOTIFY_LEVEL" != ERROR ]]; then
			notify-send -a ImgurScreenshot -u low -c "transfer.complete" -t "$ttl" "$SELF" "$msg"
		fi
	fi
}


# Copies given string to clipboard.
#
# @param {string}  input   string to copy onto clipboard.
#
# @returns {void}
copy_to_clipboard() {
	local input

	input="$1"

	if [[ "$IS_MAC" -eq 1 ]]; then
		pbcopy <<< "$input"
	elif [[ -n "$DISPLAY" ]]; then
		{ command -v xsel >/dev/null 2>/dev/null && echo -n "$input" | xsel --input --clipboard; } \
			|| { command -v xclip >/dev/null 2>/dev/null && echo -n "$input" | xclip -selection clipboard; } \
			|| err -L "didn't copy to clipboard - xsel nor xclip are installed"
	else
		err -L "Haven't copied to the clipboard:  no \$DISPLAY"
	fi
}


# Uploads given image(s) to imgur
#
# @param {string...}  files  files to upload.
#
# @returns {void}
upload_images() {
	local files file response url dhash

	declare -a files=("$@")

	for file in "${files[@]}"; do
		response="$(upload_image "$file")"
		is_request_success "$response" || { err "uploading [$file] failed"; HAS_ERRORS=1; continue; }

		# get image url link
		url=$(get_value_from_response "$response" "link" | sed -e 's/\\//g')
		is_valid_url "$url" || err "uploaded image resulted in [$url] link"
		dhash=$(get_value_from_response "$response" "deletehash")
		is_null_or_empty "$dhash" && err "no deletehash found in image [$file] upload response [$response]"

		info "[$file] uploaded: $url deletehash=[$dhash] (https://imgur.com/delete/${dhash})"

		if [[ -n "$AUTO_DELETE_DELAY" ]]; then
			info "Deleting image [$url] in $AUTO_DELETE_DELAY"
			nohup /bin/bash -c "sleep $AUTO_DELETE_DELAY && delete_image_auto '$dhash' '$url'" >/dev/null 2>&1 &
		fi

		[[ "$COPY_URL_TO_CLIP" == true ]] && copy_to_clipboard "$url"
	done

}


# Deletes uploaded images corresponding to supplied deletehashes.
#
# @param {string...}  hashes  imgur image deletion hashes.
#
# @returns {void}
delete_images() {
	local hash hashes

	declare -a hashes=("$@")

	for hash in "${hashes[@]}"; do
		response="$(api_call -r "image/${hash}" -X DELETE)"
		is_request_success "$response" || { err "deleting hash [$hash] failed"; HAS_ERRORS=1; continue; }

		info "Deletion OK:  $hash"
	done
}


# Verifies whether call to imgur api was successful (implies basic response type).
#
# @param {string}  response   api response body.
#
# @returns {bool}  true, if request was successful.
is_request_success() {
	local response status success

	response="$1"

	status=$(get_value_from_response_no_inverted_commas "$response" "status")
	success=$(get_value_from_response_no_inverted_commas "$response" "success")

	if [[ "$success" != true ]]; then
		echo "$response" > ~/tmp/resp_err
		err -N "request failed with status [$status]: $(jq -r .data.error <<< "$response")"
		return 1
	fi

	return 0
}


# Prints, notifies & logs given error message.
#
# @param {opt}      -N   OPTIONAL; don't open notification window.
# @param {opt}      -L   OPTIONAL; don't log the message.
# @param {string}   msg   error message.
#
# @returns {void}
err() {
	local opt no_notif no_log msg OPTIND

	while getopts "NL" opt; do
		case "$opt" in
			N) no_notif=1 ;;
			L) no_log=1 ;;
			*) usage; exit 1 ;;  # do not call fail() to avoid circular dep
		esac
	done
	shift $((OPTIND-1))

	msg="$1"

	>&2 echo -e "${COLORS[RED]}${SELF}:${COLORS[OFF]} ${msg:-"ERR"}" 1>&2

	if [[ "$no_notif" -ne 1 ]]; then
		notify -t 0 ERROR "$msg"
	fi

	if [[ "$no_log" -ne 1 ]]; then
		echo "    ERR [$JOB_ID] $msg" >> "$LOG_FILE"
	fi
}


# Convenience method for err()
fail() {
	err "$@"
	exit 1
}


# Prints, notifies & logs given informational message.
#
# @param {opt}      -N   OPTIONAL; don't open notification window.
# @param {opt}      -L   OPTIONAL; don't log the message.
# @param {string}   msg   message.
#
# @returns {void}
info() {
	local opt no_notif no_log msg OPTIND

	while getopts "NL" opt; do
		case "$opt" in
			N) no_notif=1 ;;
			L) no_log=1 ;;
			*) usage; fail ;;
		esac
	done
	shift $((OPTIND-1))

	msg="$1"

	>&2 echo -e "${COLORS[YELLOW]}${SELF}:${COLORS[OFF]} ${msg:-"--info lvl message placeholder--"}"

	if [[ "$no_notif" -ne 1 ]]; then
		notify INFO "$msg"
	fi

	if [[ "$no_log" -ne 1 ]]; then
		echo "INFO [$JOB_ID] $msg" >> "$LOG_FILE"
	fi
}


# Checks if all required dependiencies are met.
#
# @returns {bool}  true, if all required dependencies are installed; false if
#                  _any_ is missing.
check_dependencies() {
	local prog fail

	fail=0
	for prog in curl jq; do
		command -v "$prog" >/dev/null || { err -L "[$prog] not installed"; fail=1; }
	done

	return $fail
}


# Loads required authentication configuration required for authenticated api calls.
#
# @returns {void}
load_access_token() {
	local expired preemptive_refresh_time

	TOKEN_EXPIRE_TIME=0  # set default, in case it can't be found in $CREDENTIALS_FILE yet

	[[ -s "$CREDENTIALS_FILE" ]] && source "$CREDENTIALS_FILE"
	[[ -z "$CLIENT_ID" || -z "$CLIENT_SECRET" || -z "$REFRESH_TOKEN" ]] && init_auth

	preemptive_refresh_time="$((5 * 60))"
	expired="$(($(date +%s) > (TOKEN_EXPIRE_TIME - preemptive_refresh_time)))"

	if [[ "$expired" -eq 1 ]]; then
		info -LN "access token expired, refreshing..."
		refresh_access_token
	fi

	chmod 600 "$CREDENTIALS_FILE"
}


# Asks user for their client_id, client_secret, and resulting
# callback url from the autorization call. This is intended to be ran
# only during initial script setup.
#
# This function also defines ACCESS_TOKEN, REFRESH_TOKEN in
# our global scope, and passes forward for validation & persisting.
#
# @returns {void}
init_auth() {
	local url expires_in

	if [[ -z "$CLIENT_ID" ]]; then
		read -r -p 'imgur client ID: ' CLIENT_ID
		[[ -z "$CLIENT_ID" ]] && fail -NL "no clientId given, abort"
		echo "CLIENT_ID='$CLIENT_ID'" >> "$CREDENTIALS_FILE"
	fi

	if [[ -z "$CLIENT_SECRET" ]]; then
		read -r -p 'imgur client secret: ' CLIENT_SECRET
		[[ -z "$CLIENT_SECRET" ]] && fail -NL "no client secret given, abort"
		echo "CLIENT_SECRET='$CLIENT_SECRET'" >> "$CREDENTIALS_FILE"
	fi

	if [[ -z "$REFRESH_TOKEN" ]]; then
		url="https://api.imgur.com/oauth2/authorize?client_id=${CLIENT_ID}&response_type=token"
		info -NL "please open [${COLORS[CYAN]}${url}${COLORS[OFF]}] in browser"
		info -NL "and copy the resulting redirect url in here"

		read -r -p 'redirect url: ' url
		[[ -z "$url" ]] && fail -NL "given redirect url [$url] doesn't look right"

		ACCESS_TOKEN="$(perl -nle 'print $& if m{(access_token=)\K\w+}' <<< "$url")"
		REFRESH_TOKEN="$(perl -nle 'print $& if m{(refresh_token=)\K\w+}' <<< "$url")"
		expires_in="$(perl -nle 'print $& if m{(expires_in=)\K\w+}' <<< "$url")"

		persist_tokens "$expires_in"
	fi
}


# Refreshes our access_token & refresh_token and defines them in our global scope.
#
# @returns {void}
refresh_access_token() {
	local response

	# exchange the refresh token for access_token and refresh_token
	response="$(curl --compressed -sSL \
		--stderr - \
		-F "client_id=${CLIENT_ID}" \
		-F "client_secret=${CLIENT_SECRET}" \
		-F "grant_type=refresh_token" \
		-F "refresh_token=${REFRESH_TOKEN}" \
		"$TOKEN_URL")"

	[[ $? -ne 0 ]] && fail "refreshing access_token failed"
	ACCESS_TOKEN="$(jq -r .access_token <<< "$response")"
	REFRESH_TOKEN="$(jq -r .refresh_token <<< "$response")"
	expires_in="$(jq -r .expires_in <<< "$response")"

	persist_tokens "$expires_in"
}


# Persists api secret data into config file for future usage.
# Note renewed access_token & refrsh_token are assumed to have
# already been defined in global scope.
#
# @param {int}  expires_in    token expiration delta received from imgur.
#
# @returns {void}
persist_tokens() {
	local expires_in key val tmp

	expires_in="$1"

	tmp="/tmp/.${SELF}-$RANDOM"

	if is_null_or_empty "$ACCESS_TOKEN"; then
		fail "[\$access_token] is missing"
	elif is_null_or_empty "$REFRESH_TOKEN"; then
		fail "[\$refresh_token] is missing"
	elif is_null_or_empty "$expires_in"; then
		fail "[\$expires_in] is missing"
	fi

	TOKEN_EXPIRE_TIME="$(( $(date +%s) + expires_in ))"

	# replace values in $CREDENTIALS_FILE with newly fetched ones:
	for key in ACCESS_TOKEN REFRESH_TOKEN TOKEN_EXPIRE_TIME; do
		# first remove existing value:
		if [[ "$IS_MAC" -eq 1 ]]; then
			cp -- "$CREDENTIALS_FILE" "$tmp"
			sed "/$key/d" < "$tmp" > "$CREDENTIALS_FILE"
		else
			sed --follow-symlinks -i "/$key/d" "$CREDENTIALS_FILE"
		fi

		val="$(eval echo "\$$key")"
		echo "${key}='$val'" >> "$CREDENTIALS_FILE"
	done

	[[ -f "$tmp" ]] && rm -f -- "$tmp"
}


# Function to be called from backgrounded process in order to
# delete uploaded image.
#
# @param {string} dhash   image deletion hash.
# @param {string} url     url to uploaded image to be deleted.
#
# @returns {void}
delete_image_auto() {
	local dhash url response

	dhash="$1"
	url="$2"

	response="$(api_call -r "image/${dhash}" -X DELETE)"

	if is_request_success "$response"; then
		info -N "Image successfully deleted (delete hash: $dhash)."
	else
		err "image @ [$url] could not be deleted (delete hash $dhash): ${response}."
	fi
}


#################
###### Entry
#################
############# START CONFIG #############
LOGIN=false  # true if we should authenticate with our own user.
ALBUM_ID=""
ANON_CLIENT_ID=f9012166f47bc38  # client_id to use for non-authenticated operations
CREDENTIALS_FILE="$CONF_ROOT/credentials.conf"

API_CALL_CONNECT_TIMEOUT_SEC=5
API_CALL_TIMEOUT_SEC=60
API_CALL_RETRIES=1

LOG_FILE="$HOME/.${SELF}.log"

AUTO_DELETE_DELAY=""  # if set, uploaded image(s) will be deleted after this delay; value should be accepted by $sleep
COPY_URL_TO_CLIP=true
ENABLE_NOTIFICATIONS=true
NOTIFY_LEVEL=INFO  # 'INFO' if all levels should be notified; 'ERROR' if only errors should be notified

############## END CONFIG ##############

# config items above can be overridden in $CONF_FILE
if [[ -s "$CONF_FILE" ]]; then
	source "$CONF_FILE"
fi


while [[ "$1" == -* ]]; do
	case "$1" in
		-a|--album-id)
			ALBUM_ID="$2"; shift 2 ;;
		-t|--title)
			TITLE="$2"; shift 2 ;;
		-l|--login)
			LOGIN="$2"; shift 2 ;;
		-D|--auto-delete)
			AUTO_DELETE_DELAY="$2"; shift 2 ;;
		-h|--help)
			usage
			exit 0
			;;
		-v|--version)
			info -NL "Version:  $VERSION"
			exit 0
			;;
		-d|--delete) MODE=DELETE; shift ;;
		--) shift; break ;;
		*)
			usage
			exit 1
			;;
	esac
done


check_dependencies || fail -L "please install required dependencies"
[[ $# -eq 0 ]] && { err -LN "no input given"; usage; exit 1; }
[[ "$LOGIN" == true ]] && load_access_token

if [[ "$MODE" == DELETE ]]; then
	delete_images "$@"
else
	upload_images "$@"
fi

exit $HAS_ERRORS
